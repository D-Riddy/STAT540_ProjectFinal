---
title: "STAT540 - Project 2"
author: "David A. Riddy"
date: '`r Sys.Date()`'
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, echo = TRUE, message = FALSE}
# load the packages for graphing and data wrangling
library(ggplot2)
library(dplyr)
```

**Note:** If you `Rmd` file submission knits you will receive total of **(10 points)**.

For the data wrangling use function from the `dplyr` package

# Project Objectives?

Leading up to the 2016 presidential election, many pollsters predicted that the Democratic candidate, Hillary Clinton, would win a "decisive victory.". However, as we all know, the election was won by the Republican candidate, and current president, Donald Trump. In general biases, not accounted for by prediction models, often affect many pollsters. In this project, you are going to further investigate these biases through comparisons across both national and state-level races.

The project requires an **.RData** file, `election_polls.RData`, containing a `data.frame` (`polls`) with several years worth of polling data (2008, 2010, 2012, 2014 and 2016). The polls cover federal elections for house representatives, senators and the president, and includes polling data from up to a year before the election date.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
load("elections_polls.RData")
str(polls)
```

The `polls` `data.frame` contains the following columns:

-   `race`: race identifier year_electiontype_location.
-   `race_state`: race identifier year_electiontype_state. In contrast to the previous column, this identifier ignores information about counties and only contains information at the state level.
-   `state`: abbreviation of state of the election
-   `state_long`: full name of the state
-   `type`: type of race. Could be either presidential (Pres), senatorial election (Sen-G) or house representative election (House-G).
-   `year`: election year
-   `pollster`: name of the pollster
-   `samplesize`: size of the sample used in the poll
-   `startdate`: start date of the pole. If this date was not available, this will be the same as enddate
-   `enddate`: end date of the pole
-   `democrat_name`: name of the democratic candidate
-   `democrat_poll`: percentage of people from the poll saying they would vote for the democratic candidate
-   `democrat_result`: actual percentage of people voting for the democratic candidate in the election
-   `republican_name`: name of the republican candidate
-   `republican_poll`: percentage of people from the poll saying they would vote for the republican candidate
-   `republican_result`: actual percentage of people voting for the republican candidate in the election

## Part 1 (10 pts)

Subset the `polls` `data.frame` to only keep polls which ended within approximately 6 weeks preceding any [Election Day (i.e. in October or November, 10th and 11th months).

**Hint:** you might need to extract the month from the `enddate`. The `strftime` function might be useful for this.

**Solution**:

```{r}

# hint  use the sample code below
polls_subset <- polls %>% 
   mutate( endmonth = strftime( polls$enddate, "%m") ) %>% #converts months as decimal number 01-12
   filter( endmonth %in% c("10", "11") ) #Keeps only October and November.
```

## Part 2 (10 pts)

For each poll, calculate the difference between the fraction of people saying they would vote for the Republican Party and the fraction of people saying they would vote for the Democratic Party. Add these values to your `data.frame` as a new column, `spread`. Similarly, calculate the true (actual) difference between the fraction of people who ended up voting for the Republican Party and the fraction of people who ended up voting for the Democratic Party. Create new variable `spread_act` by adding the true (actual) difference, to your `data.frame`.

**Solution**:

```{r}
# Calculate the spread between Republican and Democratic votes in the polls
polls <- polls %>%
  mutate(spread = republican_poll - democrat_poll,  # Difference in polling
         spread_act = republican_result - democrat_result)   # Difference in actual votes

# Display the updated data frame to verify the new columns
head(polls)


```

## Part 3 (10 pts)

Now collapse polls for each race. For this, group polls by the type, year, and state of the corresponding election. There are several polls for each race, and each one provides an approximation of the real $\theta$ value. Generate a point estimate for each race, $\hat{\theta}$, that summarizes the polls for that race using the following steps: [1] use the column `race_state` to group polls by type, year, and state, and [2] use the `summarize` function to generate a new `data.frame` called `reduced_polls` with the following columns:

1.  the mean `spread`,
2.  the standard deviation of the `spread`,
3.  the mean `spread_act`, and
4.  the number of polls per race.

Make sure you also keep information about the `year` and `state` of each race in this new `data.frame`.

**Solution**:

```{r}
# Collapse polls by grouping them by type, year, and state (using 'race_state') and summarizing the data
reduced_polls <- polls %>%
  group_by(race_state, year, state) %>%   # Group by race_state, year, and state
  summarize(
    mean_spread = mean(spread, na.rm = TRUE),            # Mean of spread
    sd_spread = sd(spread, na.rm = TRUE),                # Standard deviation of spread
    mean_spread_act = mean(spread_act, na.rm = TRUE),     # Mean of actual spread
    n_polls = n()                                        # Number of polls per race
  ) %>%
  ungroup()  # Ungroup to return to a regular data frame

# Display the reduced data frame to verify
head(reduced_polls)

```

## Part 4 (10 pts)

Note that the previous question merges different congressional elections held in the same year across districts in a state. Thus, using the collapsed `data.frame` from the previous question, filter out races from congressional elections. Also, **filter** out races that had less than 3 polls. For each remaining races, build a 95% confidence interval for $\hat{\theta}$. Include the boundaries of these confidence intervals in the `reduced_polls` `data.frame`.

Hint: C.I has the form `avg +/- 1.96*sd/sqrt(n)`

**Solution**:

```{r}
# Filter out congressional elections (assuming `type` is the election type column)
# and filter out races with fewer than 3 polls
reduced_polls_filtered <- reduced_polls %>%
  filter(n_polls >= 3)  # Keep only races with 3 or more polls

# Calculate the 95% confidence interval and add the lower and upper bounds to the data frame
reduced_polls_filtered <- reduced_polls_filtered %>%
  mutate(
    ci_lower = mean_spread - 1.96 * (sd_spread / sqrt(n_polls)),  # Lower bound of C.I.
    ci_upper = mean_spread + 1.96 * (sd_spread / sqrt(n_polls))   # Upper bound of C.I.
  )

# Display the updated data frame with confidence intervals
head(reduced_polls_filtered)


```

## Part 5 (10 pts)

For each election type in each year, calculate the fraction of states where the actual result was **outside** of the 95% confidence interval. Which race was the most unpredictable, (i.e. for which race was the polling data most inaccurate compared to the actual result)?

**Solution**:

```{r}

# Create a new column to flag whether the actual result (mean_spread_act) is outside the 95% confidence interval
reduced_polls_filtered <- reduced_polls_filtered %>%
  mutate(outside_ci = ifelse(mean_spread_act < ci_lower | mean_spread_act > ci_upper, 1, 0))  # 1 if outside, 0 if inside

# Calculate the fraction of states where the actual result was outside the confidence interval
unpredictability_summary <- reduced_polls_filtered %>%
  group_by(race_state, year, state) %>%
  summarize(
    fraction_outside_ci = mean(outside_ci),  # Calculate fraction of states where actual result was outside C.I.
    n_races = n()  # Number of races in each group
  ) %>%
  arrange(desc(fraction_outside_ci))  # Sort to find the most unpredictable race

# Display the summary to identify the most unpredictable race
unpredictability_summary

```

The 2012 Senatorial polling data was the most inaccurate, followed closely by the 2016 presidential election.

## Part 6 (10 pts)

Using data from *only* the 2016 presidential election, make a plot of states ($x$-axis) and $\hat{\theta}$ estimates ($y$-axis). Using the `gg_errorbar` function, include the 95% confidence intervals of $\hat{\theta}$ for each state. Finally, using a different color, include the actual results for each state. Describe the resulting plot.

**Solution**:

```{r}

# Calculate the 95% confidence interval if not already present
reduced_polls <- reduced_polls %>%
  mutate(
    ci_lower = mean_spread - 1.96 * (sd_spread / sqrt(n_polls)),  # Lower bound of CI
    ci_upper = mean_spread + 1.96 * (sd_spread / sqrt(n_polls))   # Upper bound of CI
  )

# Filter the data for the 2016 presidential election using the race_state column
reduced_polls %>%
  filter(grepl("Pres", race_state), year == 2016) %>%
  mutate(state = reorder(state, mean_spread, mean)) %>%

  ggplot(aes(state, mean_spread)) +
  geom_point() +  # Plot the point estimates (mean spread)

  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), colour = "black", width = 0.8) +  # Add error bars (95% CI)
  geom_point(aes(y = mean_spread_act), color = "red") +  # Add actual results (mean_spread_act) in red

  theme_classic() +  # Apply classic theme
  theme(axis.text.x = element_text(angle = -90, vjust = 0.5)) +  # Rotate x-axis labels
  ylab("Republican - Democrat") +  # Label for y-axis
  ggtitle("2016 Presidential Election Polling (black) vs Outcome (red)") +  # Title of the plot
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey")  # Add a horizontal line at y = 0




```

It is clear that most state-level results fall outside the 95% confidence interval, and in the Republican direction.

## Part 7 (10 pts)

Which states did Donald Trump win in the 2016 presidential election, despite the entire 95% confidence intervals being in favor of his opponent, Hillary Clinton?

**Solution**:

```{r}
# Filter for the 2016 presidential election and find states where Trump won despite the CI favoring Clinton
trump_wins_against_ci <- reduced_polls %>%
  filter(grepl("Pres", race_state), year == 2016) %>%  # Filter for presidential races in 2016
  filter(ci_upper < 0, mean_spread_act > 0) %>%        # CI favors Clinton (both bounds < 0) but actual result favors Trump
  select(state, mean_spread_act, ci_lower, ci_upper)   # Select relevant columns for display

# Display the states where Trump won despite the CI favoring Clinton
trump_wins_against_ci

```

Donald Trump won Florida, Michigan, North Carolina, Pennsylvania, and Wisconsin, despite the entire 95% confidence intervals from polling data predicting a win for Hillary Clinton.

## Part 8 (10 pts)

Looking again at all races, calculate the the difference between $\theta$ and $\hat{\theta}$ (Hint: use the data for all races in the `reduced_polls` object created in Part 4). We call this the bias term. Add these values as a column to `reduced_polls`.

**Solution**:

```{r}
# Calculate the bias term and add it as a new column to reduced_polls
reduced_polls <- reduced_polls %>%
  mutate(bias = mean_spread_act - mean_spread)  # Difference between actual and estimated results

# Display the updated data frame with the new bias column
head(reduced_polls)

```

## Part 9 (10 pts)

Plot and compare the distribution of bias terms for races in each year. Describe the bias patterns. Are these centered around zero? Give possible explanations.

**Solution**:

```{r}
# Create a boxplot to compare the distribution of bias terms for races in each year
ggplot(reduced_polls, aes(x = factor(year), y = bias)) +
  geom_boxplot() +  # Boxplot to show the distribution of bias
  theme_classic() +  # Classic theme for simplicity
  xlab("Year") +  # Label for x-axis
  ylab("Bias (theta - hat(theta))") +  # Label for y-axis
  ggtitle("Distribution of Bias Terms by Year")  # Title of the plot

```
